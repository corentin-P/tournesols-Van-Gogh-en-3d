<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Van Gohg : Les tournesols</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
			.centre{text-align: center;}
		</style>
		<link rel="stylesheet" href="styles.css">
	</head>

	<body>
		<!-- API importé du site de Three.js -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
		<script type="importmap">
			{
				"imports": {
					"three": "https://threejs.org/build/three.module.js",
					"three/addons/": "https://threejs.org/examples/jsm/"
				}
			}
		</script>
    <script type="module" src="lib/dat.gui.min.js"></script> 
    <script type="module" src="lib/jquery-1.8.3.min.js"></script> 
		
	 
    <h1 class="centre">Les tournesols de Van Gohg</h1>

	<div class="center links">
		<a href="rendu.html" class="link">Voir le rendu 3D</a>
		<a href="consignes.html" class="link">Voir les consignes</a>
	</div>

	<h2 class="text">Présentation du projet</h2>
	<script  type='module' src="projet.js">
	</script>
     <!--Pour mettre le rendu Web GL centré -->
	 <div class="container text">
		 <div id="webGL"></div>
		 <div class="tableau"><img src="tableau.jpg" alt="Photo du tableau des tournesols de Van Gohg"></div>
	</div>
		
	<p class="text">Le sujet de ce projet était de refaire un tableau en 3D. Nous devions y intégrer certains principes vus en cours, tels que les géométries, les différentes textures, un skybox, les sprites, une intéraction par gui etc. </p>
	<p class="text">Pour ce projet, j'ai choisi de refaire les tournesols de Van Gohg, une peinture très célèbre</p>
	<br>
	 <div>
		<h2 class="text">Explications techniques</h2>
		<p class="text">Ce projet est crée à l'aide de la bibliothèque 3D ThreeJS. Nous devons tout d'abord créer une scène (ce que nous voyons), une caméra (le point de vue nous avons sur la scène), des lumières pour éclairer la scène et voir ce qui s'y trouve. <br>
			Nous pouvons créer des objets en combinant une géométrie (taille et forme) et une texture (couleur ou image se collant sur la géométrie) <br>
			Par la suite, nous pouvons rajouter des contrôles (petite fenêtres à droite) pour intéragir avec la scène, et des animations pour faire bouger les différents objets. Ils sont créés dans la fonction setupGui() et sont reliés à des variables du fichier (celles déclarées en haut, globales à toutes les fonctions)
		</p>

		<p class="text">Il y a 4 lumières, une ambiante pour voir légèrement puis 3 directionnelles différents, réparties dans les deux angles visibles de la scène et une derrière notre caméra. Une des caméra est configurée pour "émettre" des ombres. Cela permet aux objets de projeter des ombres sur les autres.</p>
		<div class="text">
			<p>Vous pouvez voir différents éléments sur ce tableau: <br> </p>
			<h3>Le vase</h3>
			<p class="text">Le vase est fait avec deux cylindres différents collés, ayant deux diamètres différents en haut et en bas (le diamètre haut du premier est égal au diamètre bas du deuxième et inversement). Le matériel du haut est un MeshPhongMaterial pour avoir le reflet de la lumière comme sur le tableau original tandis que le matériel du bas du vase est un MeshLambertMaterial pour avoir un effet plus terne. <br></p>
			<h3>Les tournesols </h3>
			<p class="text">Les tournesols sont fait à partir d'un objet 3D trouvé sur internet. L'objet est constitué d'un fichier .obj et d'un fichier .jpg. J'ai donc utilisé deux loader (OBJLoader et TextureLoader) dans le code, un loader d'objet et un loader de texture pour ensuite créer un seul objet avec sa géométrie et ses textures. Je le charge une première fois puis le clone pour avoir tous les tournesols. (le clonage est beaucoup plus efficace que de charger plusieurs fois l'objet)<br> 
				Au moment du chargement de l'objet et au clonage, je spécifie castShadow = true pour pouvoir afficher l'ombre de chaque tournesol sur le sol.</p>
			<h3>Les murs</h3>
			<p class="text">Les murs des cotés sont créés à partir d'une texture que j'ai créé sur GIMP (Il faut d'abord charger la texture avec TextureLoader puis l'appliquer à un Material). Il m'a suffit de prendre une image, mettre un fond uni et rajouter du bruit sur l'image pour faire la texture attendue. Cela donne un effet granulé pour donner l'impression de murs. <br>
				Il y a 6 géométries de murs, une pour le fond, une pour le coté gauche et 4 pour faire le tour de la fenêtre.</p>
			<h3>Le sol</h3>
			<p class="text">Le sol n'est qu'une BoxGeometry classique avec une texture MeshLambertMaterial orange pour pouvoir recevoir des ombres (le MeshBasicMaterial ne les gérant pas). Le receiveShadow est donc activé pour recevoir les ombres. <br></p>
			<h3>Le miroir</h3>
			<p class="text">Le miroir est aussi une BoxGeometrie sur lequel on applique la vue d'une caméra. J'ai donc créée une nouvelle caméra (mirrorCamera) regardant depuis derrière le vase. Elle est mise à jour à chaque boucle de rendu dans la fonction render() pour que le mirroir soit toujours correct par rapport à notre position. On applique ensuite la vue de la caméra à une texture (MeshBasicMaterial) grace à l'argument envMap.<br></p>
			<h3>La fenêtre</h3>
			<p class="text">La fenêtre est une BoxGéometrie avec un MeshBasicMaterial sur lequel la transparence est activée (transparent = true et 0<=opacity<=1). Il y a ensuite deux autres BoxGéometrie avec un MeshLambertMaterial brun pour faire les contours de la fenêtre. <br></p>
			<h3>Le papillon</h3>
			<p class="text">Le papillon est un sprite, élément 2D faisant toujours face à la caméra. J'ai choisi une image sur internet, libre de droit et l'ai transformée, détourée et exportée en PNG pour que les bords soient transparents et que l'on ne voit pas une image carrée. <br>
				Il est animé, il varie entre -20 et 20 en sur l'axe z, et les axes x et y sont calculés avec les fonctions sinus et cosinus par rapport à la position en z. Le cosinus de l'axe z permet de faire un cercle autour de l'axe y. Le cosinus sert donc à déterminer la position en x. Le sinus sert, quant à lui, à créer le mouvement de bas en haut pour donner l'impression du batement d'ailes. Il sert donc à déterminer la position en y.<br>
				Le papillon possède deux images, et le changement d'image s'effectue dès lors qu'il arrive à -20 ou 20 en z. Le déplacement est effectué en fonction du temps et non en fonction de la cadence du processeur. <br>
				La position du papillon est mise à jour dans la boucle de rendu dans la fonction render() qui appelle la fonction moveButterfly()</p>
			<h3>La skybox</h3>
			<p class="text">La SkyBox est créée à partir de 6 images trouvées sur internet. Il suffit de rajouter une skybox à la scène avec les 6 images pour la créer.<br></p>
		</div>
	 </div>
	 	

	</body>
</html>	